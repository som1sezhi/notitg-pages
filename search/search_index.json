{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Some pages about doing stuff in NotITG. Repo is here.</p> <p>Currently using a MkDocs template + Obsidian to create these pages. Is this a good idea? idk lol</p> <p>If you have any feedback/topic ideas/whatever, you can contact me at @som1sezhi on Discord.</p>"},{"location":"shader-variables/","title":"Shader variables","text":"<p>NotITG automatically passes some useful uniform variables into your custom shader programs. The default vertex shader also passes some useful varying variables into the fragment shader. These variables are listed below.</p>"},{"location":"shader-variables/#varyings","title":"Varyings","text":"<pre><code>varying vec3 position;\nvarying vec3 normal;\nvarying vec4 color;\nvarying vec2 textureCoord;\nvarying vec2 imageCoord;\n</code></pre> <ul> <li><code>position</code>: The position of this point in local space.</li> <li><code>normal</code>: The normal vector at this point, in view space. Not normalized.</li> <li><code>color</code>: The vertex color, often set via <code>Actor.diffuse()</code> and friends.</li> <li><code>textureCoord</code>: The texture coordinates at this point. These coordinates are suitable for plugging into <code>texture2D()</code> directly. For more info, see Texture padding.</li> <li><code>imageCoord</code>: The image coordinates at this point. For more info, see Texture padding.</li> </ul>"},{"location":"shader-variables/#uniforms","title":"Uniforms","text":"<pre><code>uniform float time;\nuniform float beat;\nuniform vec2 resolution;\nuniform vec2 textureSize;\nuniform vec2 imageSize;\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 textureMatrix;\nuniform sampler2D sampler0;\nuniform sampler2D sampler1;\nuniform bool isEnvMap;\n</code></pre> <ul> <li><code>time</code>: The time into the song, in seconds.</li> <li><code>beat</code>: The time into the chart, in beats.</li> <li><code>resolution</code>: The resolution of the screen. You can think of it as <code>vec2(SCREEN_WIDTH, SCREEN_HEIGHT)</code>.</li> <li><code>textureSize</code>: (not available in model shaders) The size of the actor's main texture. For more info, see Texture padding.</li> <li><code>imageSize</code>: (not available in model shaders) The actual size of the image contained within the actor's main texture. For more info, see Texture padding.</li> <li><code>modelMatrix</code>: The actor's model matrix. See the section regarding transformation matrices.</li> <li><code>viewMatrix</code>: The actor's view matrix. See the section regarding transformation matrices.</li> <li><code>projectionMatrix</code>: The actor's projection matrix. See the section regarding transformation matrices.</li> <li><code>textureMatrix</code>: Matrix that transforms texture coordinates before they are passed to the fragment shader.</li> <li><code>sampler0</code>: The actor's main texture.</li> <li><code>sampler1</code>: (model shaders only) The texture loaded in a model's alphamap slot.</li> <li><code>isEnvMap</code><sup>1</sup>: (model shaders only) True if the textures loaded with the model are sphere maps (?). Specifically, this is true whenever a sphere map is loaded in the color map or alphamap slot, except in the case where a sphere map is in the color map slot and a non-sphere-map texture is in the alphamap slot.</li> </ul>"},{"location":"shader-variables/#additional-playfield-shader-uniforms","title":"Additional playfield shader uniforms","text":"<p>The game passes some additional uniforms into playfield shaders:</p> <pre><code>uniform int iCol;\nuniform int iPlayfield;\nuniform int isHold;\nuniform int isReceptor;\nuniform float fYOffset;\nuniform float fNoteBeat;\n</code></pre> <ul> <li><code>iCol</code>: The playfield column (0-indexed).</li> <li><code>iPlayfield</code>: The playfield number (0-7 for P1-P8).</li> <li><code>isHold</code>: 1 for holds, 0 for all else.</li> <li><code>isReceptor</code>: 1 for receptors, 0 for all else.</li> <li><code>fYOffset</code>: (arrow shaders only) The y-offset of the arrow along the arrow path,   in \"pixels\". Beware that the location of the zero point is affected by mods   and is not usually located at the receptors.</li> <li><code>fNoteBeat</code>: (arrow and hold shaders only) Which beat the arrow lies on. For   holds, which beat the hold starts on.</li> </ul>"},{"location":"shader-variables/#regarding-transformation-matrices","title":"Regarding transformation matrices","text":"<p> Adapted from LearnOpenGL - Coordinate Systems by Joey de Vries, licensed under CC BY 4.0</p> <p>In most 3D games, vertex coordinates are transformed to a series of coordinate systems in order to determine where vertices should end up on screen. These coordinate systems include the following:</p> <ul> <li>Local space specifies coordinates relative to the object's origin, before any transformations are applied to the object.</li> <li>World space specifies coordinates relative to the world's origin.</li> <li>View space specifies coordinates relative to the camera's point of view.</li> <li>Clip space specifies coordinates in terms of the screen/viewport, kind of. Specifically, in clip space, points with coordinates between -1 and 1 will be visible on screen, and points outside this range will be clipped (discarded).</li> </ul> <p>These transformations are performed via a bunch of linear algebra, utilizing a series of transformation matrices that describe the transformations taking place:</p> <ul> <li>The model matrix transforms local space to world space, essentially positioning and transforming the object to its place in the world.</li> <li>The view matrix transforms world space to view space. You can think of it as positioning the camera in the world, though it's really more like transforming the whole world to move stuff into the camera's view.</li> <li>The projection matrix transforms view space to clip space. Taking the effects of perspective into account, it projects all coordinates that the camera can see (those within the camera's view frustum) into a box between (-1, -1, -1) and (1, 1, 1) so these coordinates can be easily clipped.</li> </ul> <p>The <code>modelMatrix</code>, <code>viewMatrix</code>, and <code>projectionMatrix</code> uniforms that NotITG uses work pretty much like this, though some aspects of their behaviors are a little unusual:</p> <ul> <li><code>modelMatrix</code> includes all transformations applied to the actor and its containing ActorFrames (but not any of the FOV-related stuff).</li> <li>If the actor has no FOV applied, <code>viewMatrix</code> is just the identity matrix (the transformation does nothing). If FOV is applied, <code>viewMatrix</code> translates the x- and y-coordinates by <code>-resolution / 2.0</code> (presumably to move the origin point to the center of the screen). It also performs a translation in the negative z direction, pushing the actor further into the depth axis, with the translation becoming more extreme as the FOV decreases (probably to counteract any apparent size changes caused by changing the FOV).</li> <li><code>projectionMatrix</code> seems to work pretty much as expected. Just make sure to name the uniform <code>projectionMatrix</code> and NOT <code>perspectiveMatrix</code>. Unlike what documentation on the Discord might indicate, NotITG doesn't pass anything into the <code>perspectiveMatrix</code> uniform.</li> </ul> <ol> <li> <p>I've never seen this uniform really documented anywhere, so I'm not sure if this is even officially a \"feature\". I only managed to find this one by poking around in glIntercept.\u00a0\u21a9</p> </li> </ol>"},{"location":"texture-padding/","title":"Texture padding (NPOT textures)","text":"<p>NotITG likes textures with dimensions that are powers of 2 (128x128, 512x256, etc.). If you try to load an image with dimensions that are Not Powers of Two (NPOT), NotITG will pad out the dimensions to the next highest powers of two.</p> <p>For example, here is a 200x150 image:</p> <p></p> <p>If loaded into NotITG as a sprite texture, it gets padded out to 256x256:</p> <p></p> <p>(The padding here is colored black for visualization purposes. In reality it could be transparent, contain garbage data, or in the case of AFT textures, actually be black.)</p>"},{"location":"texture-padding/#texture-coordinates-vs-image-coordinates","title":"Texture coordinates vs. image coordinates","text":"<p>This behavior gives rise to a distinction between texture size and image size, and between texture coordinates and image coordinates:</p> <p></p> <ul> <li>The texture size is the size of the whole texture, including the padding. The dimensions will always be powers of 2. In the above example, the texture size would be 256x256.</li> <li>The image size is the size of the image without padding. In the above example, the image size would be 200x150.</li> <li>With texture coordinates, values in the range [0, 1] span over the whole texture, including the padding. In the above example, (1, 1) would refer to the very bottom-right corner of the texture, while the bottom-right corner of the actual image would be located at (200/256, 150/256), or (0.78125, 0.5859375).</li> <li>With image coordinates, values in the range [0, 1] span only over the image within the texture, excluding the padding. In the above example, (1, 1) would refer to the bottom-right corner of the actual image, the same location as (0.78125, 0.5859375) in texture coordinates.</li> </ul> <p>In Lua, you can grab the texture/image dimensions of a <code>RageTexture</code> by calling its <code>GetTextureWidth()</code>/<code>GetImageWidth()</code> and <code>GetTextureHeight()</code>/<code>GetImageHeight()</code> methods.</p> <p>In shaders, the texture and image sizes are available through the uniforms <code>textureSize</code> and <code>imageSize</code> (except in model shaders). Additionally, in the fragment shader, the current texture/image coordinates are available through the varying variables <code>textureCoord</code> and <code>imageCoord</code>.</p>"},{"location":"texture-padding/#dealing-with-npot-textures","title":"Dealing with NPOT textures","text":"<p>If you actually assign a NPOT texture to a sprite, you may notice that the image displays correctly, without any padding visible. In those cases, NotITG automatically sets the sprite's texture coordinates to only cover the image's portion of the texture, hiding away the padding. However, in situations where you assign texture coordinates yourself or otherwise manipulate them directly, you will have to deal with the padding yourself.</p> <p>This can be especially problematic if you're using something like <code>Sprite.customtexturerect()</code> or <code>Sprite.texcoordvelocity()</code> to repeat a texture across a sprite. The entire texture will be repeated, including the padding, leaving weird gaps in between the images.</p> <p></p> <p>The best way to deal with this issue, and with NPOT texture issues in general, is to just avoid them entirely and use power-of-2 textures. That way, you won't have to worry about the differences between texture and image coordinates, as they will be equivalent, and stuff like <code>customtexturerect()</code> will work as expected.</p> <p>This is unfortunately not always possible, particularly when working with AFTs (the image size will be the size of your window, which will likely not have power-of-2 dimensions). You will have to manually account for the padding when inputting texture coordinates. You also won't be able to  repeat textures using <code>customtexturerect()</code>, etc. properly at all; you'll have to emulate these effects using a shader<sup>1</sup>. Luckily for us, in all of the above cases, we have <code>img2tex()</code> to help.</p>"},{"location":"texture-padding/#img2tex-for-shaders","title":"<code>img2tex()</code> (for shaders)","text":"<p>In NotITG shader code, you will often find the function <code>img2tex()</code> lying around somewhere:</p> <pre><code>vec2 img2tex( vec2 v ) { return v / textureSize * imageSize; }\n</code></pre> <p>This function takes in a pair of image coordinates and converts them to texture coordinates. This function is very useful because it allows you to perform your manipulations in image coordinate space first, which is a lot easier to work with in many situations, before converting them to texture coordinates to plug into <code>texture2D()</code>.</p> <p>As an example of what happens when you don't use <code>img2tex()</code> before plugging into <code>texture2D()</code>, let's say you have an AFT-sprite setup and you want to create an effect where the AFT texture tiles across the screen. You write this shader:</p> <pre><code>#version 120\n\nvarying vec2 imageCoord;\n\nuniform sampler2D sampler0;\n\nvoid main() {\nvec2 uv = imageCoord;\n\n// repeat across the screen 4 times\nuv = fract(uv * 4.0);\n\n// sample from texture\ngl_FragColor = texture2D(sampler0, uv);\n}\n</code></pre> <p>and get this horrible-looking result<sup>2</sup>:</p> <p></p> <p>The problem here is that <code>uv</code> is specified in terms of image coordinates, but <code>texture2D()</code> expects texture coordinates, so when <code>uv</code> is passed into <code>texture2D()</code>, the game starts sampling across the entire texture, including the ugly padding.</p> <p>To fix this, you can use <code>img2tex()</code> to convert <code>uv</code> to texture coordinates before passing into <code>texture2D()</code>:</p> <pre><code>#version 120\n\nvarying vec2 imageCoord;\n\nuniform vec2 textureSize;\nuniform vec2 imageSize;\nuniform sampler2D sampler0;\n\nvec2 img2tex( vec2 v ) { return v / textureSize * imageSize; }\n\nvoid main() {\nvec2 uv = imageCoord;\n\n// repeat across the screen 4 times\nuv = fract(uv * 4.0);\n\n// sample from texture, converting to texture coords first\ngl_FragColor = texture2D(sampler0, img2tex(uv));\n}\n</code></pre> <p></p>"},{"location":"texture-padding/#img2tex-for-lua","title":"<code>img2tex()</code> (for Lua)","text":"<p>If you're not writing a shader but still need to convert image coordinates to texture coordinates in Lua, you can adapt <code>img2tex()</code> for use in Lua code. AFAIK there is no commonly-used piece of code for doing this sort of thing, but here's one I made just now:</p> <pre><code>function img2tex(texture, vx, vy)\n    local texw, texh = texture:GetTextureWidth(), texture:GetTextureHeight()\n    local imgw, imgh = texture:GetImageWidth(), texture:GetImageHeight()\n    return vx / texw * imgw, vy / texh * imgh\nend\n</code></pre> <p>This could be useful for e.g. setting texture coordinates on a polygon with an AFT texture:</p> <pre><code>polygon:SetVertexTexCoord(i, img2tex(tex, x, y))\n</code></pre>"},{"location":"texture-padding/#npot-textures-on-models","title":"NPOT textures on models","text":"<p>NPOT textures on models (specifically, textures assigned to the model directly via its TXT file) are handled quite a bit differently. Instead of padding out the image, the image is stretched out to the next-highest power-of-2 dimensions. This is probably so that the original texture coordinates that come with the model can still be used to sample from its texture unchanged.</p> <p>For example, the 200x150 image from earlier would be resized to 256x256 as a model texture:</p> <p></p> <p>This stretching does not seem to be applied to NPOT textures originating from somewhere else (e.g. an AFT) and applied to the model later. This can cause problems when the model's original texture coordinates are used to sample the texture you just applied, leading to padding showing up on screen. You could try to correct the texture coordinates on the model yourself before loading it into the game, or you could correct it in-game using a shader and <code>img2tex()</code>.</p> <p>If you go the shader route, beware that <code>imageSize</code> and <code>textureSize</code> are not passed into model shaders by default, for some reason. You will have to pass those in yourself for <code>img2tex()</code> to work, e.g.:</p> <pre><code>myModel:GetShader():uniform2f('textureSize', tex:GetTextureWidth(), tex:GetTextureHeight())\nmyModel:GetShader():uniform2f('imageSize', tex:GetImageWidth(), tex:GetImageHeight())\n</code></pre> <p>Also, note that the model's original texture coordinates act as your desired image coordinates in this situation, which you want to convert to texture coordinates for the texture you just applied. Since the model's original texture coordinates is what's being passed into <code>textureCoord</code>, you'll want to do <code>img2tex(textureCoord)</code> instead of  <code>img2tex(imageCoord)</code>.</p> <ol> <li> <p>Or at least, a shader would be the simplest/most direct way of going about it IMO. I can think of some quite convoluted shaderless approaches...\u00a0\u21a9</p> </li> <li> <p>You may notice that the AFT image here looks like it's positioned at the bottom-left corner of the texture instead of the top-left. In fact, the AFT image is actually still positioned at the top-left of the texture, but the image is flipped vertically for some reason. Common AFT-sprite setups, such as the Mirin Template's <code>sprite()</code>, will then flip the sprite vertically to compensate, so the screen appears right-side up, but the (0, 0) texture/image coordinate will end up at the bottom-left corner of the image.\u00a0\u21a9</p> </li> </ol>"},{"location":"xml-lua-highlighting/","title":"XML-Lua syntax highlighting","text":"<p>Many modfiles have their code written in a strange combination of XML and Lua, with Lua code embedded within the attributes of XML tags. Thus, a regular XML syntax highlighter would paint all the Lua code the same color, which isn't super helpful for reading Lua. Some modern templates (e.g. Mirin v5) have the Lua and XML separated out into different files, allowing for regular Lua syntax highlighting to work, but the problem remains when trying to read code from files that don't use these templates.</p> <p>To fix this issue, custom syntax highlighters for mixed XML-Lua have been developed for various text editors. Here are all the ones I could find on the NotITG Discord:</p> <ul> <li>for Notepad++</li> <li>for Sublime Text</li> <li>for Vim</li> <li>for VS Code</li> </ul> <p>(Disclaimer: I haven't tested for myself if all of these work; the only one I have personally installed is for VS Code.)</p>"}]}